<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MAGMA: single precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>single precision<br/>
<small>
[<a class="el" href="group__magma__gesvd__driver.html">SVD: driver</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__sgesvd__driver.html#ga8df63bf7db0980ba88ae50438461eead">magma_sgesdd</a> (magma_vec_t jobz, magma_int_t m, magma_int_t n, float *A, magma_int_t lda, float *s, float *U, magma_int_t ldu, float *VT, magma_int_t ldvt, float *work, magma_int_t lwork, float *rwork, magma_int_t *iwork, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SGESDD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors, by using divide-and-conquer method.  <a href="#ga8df63bf7db0980ba88ae50438461eead"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__sgesvd__driver.html#gace559652f005a7a289f1831c66299579">magma_sgesvd</a> (magma_vec_t jobu, magma_vec_t jobvt, magma_int_t m, magma_int_t n, float *A, magma_int_t lda, float *s, float *U, magma_int_t ldu, float *VT, magma_int_t ldvt, float *work, magma_int_t lwork, float *rwork, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SGESVD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and/or right singular vectors.  <a href="#gace559652f005a7a289f1831c66299579"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8df63bf7db0980ba88ae50438461eead"></a><!-- doxytag: member="sgesdd.cpp::magma_sgesdd" ref="ga8df63bf7db0980ba88ae50438461eead" args="(magma_vec_t jobz, magma_int_t m, magma_int_t n, float *A, magma_int_t lda, float *s, float *U, magma_int_t ldu, float *VT, magma_int_t ldvt, float *work, magma_int_t lwork, float *rwork, magma_int_t *iwork, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgesdd </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SGESDD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors, by using divide-and-conquer method. </p>
<p>The SVD is written</p>
<p>A = U * SIGMA * transpose(V)</p>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns VT = V**T, not V.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobz</em>&nbsp;</td><td>magma_vec_t Specifies options for computing all or part of the matrix U:</p>
<ul>
<li>= MagmaAllVec: all M columns of U and all N rows of V**T are returned in the arrays U and VT;</li>
<li>= MagmaSomeVec: the first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT;</li>
<li>= MagmaOverwriteVec: If M &gt;= N, the first N columns of U are overwritten on the array A and all rows of V**T are returned in the array VT; otherwise, all columns of U are returned in the array U and the first M rows of V**T are overwritten on the array A;</li>
<li>= MagmaNoVec: no columns of U or rows of V**T are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>INTEGER The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>REAL array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if JOBZ = MagmaOverwriteVec, if M &gt;= N, A is overwritten with the first N columns of U (the left singular vectors, stored columnwise); otherwise, A is overwritten with the first M rows of V**T (the right singular vectors, stored owwise).</li>
<li>if JOBZ != MagmaOverwriteVec, the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s</em>&nbsp;</td><td>REAL array, dimension (min(M,N)) The singular values of A, sorted so that S(i) &gt;= S(i + 1).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>U</em>&nbsp;</td><td>REAL array, dimension (LDU,UCOL) UCOL = M if JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N; UCOL = min(M,N) if JOBZ = MagmaSomeVec.</p>
<ul>
<li>If JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N, U contains the M-by-M orthogonal matrix U;</li>
<li>if JOBZ = MagmaSomeVec, U contains the first min(M,N) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBZ = MagmaOverwriteVec and M &gt;= N, or JOBZ = MagmaNoVec, U is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldu</em>&nbsp;</td><td>INTEGER The leading dimension of the array U. LDU &gt;= 1; if JOBZ = MagmaSomeVec or MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N, LDU &gt;= M.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>VT</em>&nbsp;</td><td>REAL array, dimension (LDVT,N)</p>
<ul>
<li>If JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &gt;= N, VT contains the N-by-N orthogonal matrix V**T;</li>
<li>if JOBZ = MagmaSomeVec, VT contains the first min(M,N) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBZ = MagmaOverwriteVec and M &lt; N, or JOBZ = MagmaNoVec, VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvt</em>&nbsp;</td><td>INTEGER The leading dimension of the array VT. LDVT &gt;= 1; if JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &gt;= N, LDVT &gt;= N; if JOBZ = MagmaSomeVec, LDVT &gt;= min(M,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The dimension of the array WORK. Let x = max(M,N) and y = min(M,N). The optimal block size nb can be obtained through magma_get_sgesvd_nb(N). The threshold for x &gt;&gt; y currently is x &gt;= y*11/6. Required size different than in LAPACK.* In most cases, these sizes should give optimal performance for both MAGMA and LAPACK.</p>
<ul>
<li>If JOBZ = MagmaNoVec, if x &gt;&gt; y, LWORK &gt;= 3*y + max( (2*y)*nb, 7*y ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 7*y ).</li>
<li>If JOBZ = MagmaOverwriteVec, if x &gt;&gt; y, LWORK &gt;= y*y + 3*y + max( (2*y)*nb, 4*y*y + 4*y ), prefer LWORK &gt;= y*y + 3*y + max( (2*y)*nb, 4*y*y + 4*y, y*y + y*nb ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 4*y*y + 4*y ).</li>
<li>If JOBZ = MagmaSomeVec, if x &gt;&gt; y, LWORK &gt;= y*y + 3*y + max( (2*y)*nb, 3*y*y + 4*y ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 3*y*y + 4*y ).</li>
<li>If JOBZ = MagmaAllVec, if x &gt;&gt; y, LWORK &gt;= y*y + max( 3*y + max( (2*y)*nb, 3*y*y + 4*y ), y + x ), prefer LWORK &gt;= y*y + max( 3*y + max( (2*y)*nb, 3*y*y + 4*y ), y + x*nb ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 3*y*y + 4*y ). <br/>
 If LWORK = -1 but other input arguments are legal, WORK[0] returns the optimal LWORK.</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iwork</em>&nbsp;</td><td>(workspace) INTEGER array, dimension (8*min(M,N))</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: SBDSDC did not converge, updating process failed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="gace559652f005a7a289f1831c66299579"></a><!-- doxytag: member="sgesvd.cpp::magma_sgesvd" ref="gace559652f005a7a289f1831c66299579" args="(magma_vec_t jobu, magma_vec_t jobvt, magma_int_t m, magma_int_t n, float *A, magma_int_t lda, float *s, float *U, magma_int_t ldu, float *VT, magma_int_t ldvt, float *work, magma_int_t lwork, float *rwork, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgesvd </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>jobu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&nbsp;</td>
          <td class="paramname"> <em>jobvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SGESVD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and/or right singular vectors. </p>
<p>The SVD is written</p>
<p>A = U * SIGMA * conjugate-transpose(V)</p>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns V**T, not V.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobu</em>&nbsp;</td><td>magma_vec_t Specifies options for computing all or part of the matrix U:</p>
<ul>
<li>= MagmaAllVec: all M columns of U are returned in array U:</li>
<li>= MagmaSomeVec: the first min(m,n) columns of U (the left singular vectors) are returned in the array U;</li>
<li>= MagmaOverwriteVec: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A;</li>
<li>= MagmaNoVec: no columns of U (no left singular vectors) are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobvt</em>&nbsp;</td><td>magma_vec_t Specifies options for computing all or part of the matrix V**T:</p>
<ul>
<li>= MagmaAllVec: all N rows of V**T are returned in the array VT;</li>
<li>= MagmaSomeVec: the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT;</li>
<li>= MagmaOverwriteVec: the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A;</li>
<li>= MagmaNoVec: no rows of V**T (no right singular vectors) are computed. <br/>
 JOBVT and JOBU cannot both be MagmaOverwriteVec.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>INTEGER The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>REAL array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if JOBU = MagmaOverwriteVec, A is overwritten with the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBVT = MagmaOverwriteVec, A is overwritten with the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBU != MagmaOverwriteVec and JOBVT != MagmaOverwriteVec, the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s</em>&nbsp;</td><td>REAL array, dimension (min(M,N)) The singular values of A, sorted so that S(i) &gt;= S(i+1).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>U</em>&nbsp;</td><td>REAL array, dimension (LDU,UCOL) (LDU,M) if JOBU = MagmaAllVec or (LDU,min(M,N)) if JOBU = MagmaSomeVec.</p>
<ul>
<li>If JOBU = MagmaAllVec, U contains the M-by-M orthogonal matrix U;</li>
<li>if JOBU = MagmaSomeVec, U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBU = MagmaNoVec or MagmaOverwriteVec, U is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldu</em>&nbsp;</td><td>INTEGER The leading dimension of the array U. LDU &gt;= 1; if JOBU = MagmaSomeVec or MagmaAllVec, LDU &gt;= M.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>VT</em>&nbsp;</td><td>REAL array, dimension (LDVT,N)</p>
<ul>
<li>If JOBVT = MagmaAllVec, VT contains the N-by-N orthogonal matrix V**T;</li>
<li>if JOBVT = MagmaSomeVec, VT contains the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBVT = MagmaNoVec or MagmaOverwriteVec, VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvt</em>&nbsp;</td><td>INTEGER The leading dimension of the array VT. LDVT &gt;= 1;</p>
<ul>
<li>if JOBVT = MagmaAllVec, LDVT &gt;= N;</li>
<li>if JOBVT = MagmaSomeVec, LDVT &gt;= min(M,N).</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the required LWORK. if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged superdiagonal elements of an upper bidiagonal matrix B whose diagonal is in S (not necessarily sorted). B satisfies A = U * B * VT, so it has the same singular values as A, and singular vectors related by U and VT.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>INTEGER The dimension of the array WORK. LWORK &gt;= (M+N)*nb + 3*min(M,N). For optimum performance with some paths (m &gt;&gt; n and jobu=A,S,O; or n &gt;&gt; m and jobvt=A,S,O), LWORK &gt;= (M+N)*nb + 3*min(M,N) + 2*min(M,N)**2 (see comments inside code). <br/>
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the required size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if SBDSQR did not converge, INFO specifies how many superdiagonals of an intermediate bidiagonal form B did not converge to zero. See the description of RWORK above for details. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Nov 2014 for MAGMA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
