<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MAGMA: single-complex precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>single-complex precision<br/>
<small>
[<a class="el" href="group__sparse__aux.html">Sparse auxiliary</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#gae52b910ea64209e25882d07eb1693e36">magmablas_clag2z_sparse</a> (magma_int_t M, magma_int_t N, const magmaFloatComplex *SA, magma_int_t ldsa, magmaDoubleComplex *A, magma_int_t lda, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CLAG2Z converts a COMPLEX matrix SA to a COMPLEX_16 matrix A.  <a href="#gae52b910ea64209e25882d07eb1693e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#gaf91b0658650cac167c245db7e7d8aa1d">magma_clobpcg_res</a> (magma_int_t num_rows, magma_int_t num_vecs, float *evalues, magmaFloatComplex *X, magmaFloatComplex *R, float *res)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine computes for Block-LOBPCG, the set of residuals.  <a href="#gaf91b0658650cac167c245db7e7d8aa1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#ga589d631eec0f14d10b1be5798d07dd6e">magma_clobpcg_shift</a> (magma_int_t num_rows, magma_int_t num_vecs, magma_int_t shift, magmaFloatComplex *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a Block-LOBPCG, the set of residuals (entries consecutive in memory) shrinks and the vectors are shifted in case shift residuals drop below threshold.  <a href="#ga589d631eec0f14d10b1be5798d07dd6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#ga06b2c514d7e9960e45ba4fe27982e1cb">magma_ccopyscale</a> (int n, int k, magmaFloatComplex *r, magmaFloatComplex *v, magmaFloatComplex *skp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the correction term of the pipelined GMRES according to P.  <a href="#ga06b2c514d7e9960e45ba4fe27982e1cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#gaffadeed65a929f9ef7560d8478eb3844">magma_c_spmv_shift</a> (magmaFloatComplex alpha, magma_c_sparse_matrix A, magmaFloatComplex lambda, magma_c_vector x, magmaFloatComplex beta, magma_int_t offset, magma_int_t blocksize, magma_index_t *add_rows, magma_c_vector y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a given input matrix A and vectors x, y and scalars alpha, beta the wrapper determines the suitable SpMV computing y = alpha * ( A - lambda I ) * x + beta * y.  <a href="#gaffadeed65a929f9ef7560d8478eb3844"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#ga94ef69380991d213440bdad8cdcac252">magma_vector_clag2z</a> (magma_c_vector x, magma_z_vector *y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convertes magma_c_vector from C to Z  <a href="#ga94ef69380991d213440bdad8cdcac252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#gafc756cd3ac68611fb805b1d042b22c5c">magma_sparse_matrix_clag2z</a> (magma_c_sparse_matrix A, magma_z_sparse_matrix *B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convertes magma_c_sparse_matrix from C to Z  <a href="#gafc756cd3ac68611fb805b1d042b22c5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#ga94af20db87a8a9d437c8ab2de15b96cd">magma_vector_slag2d</a> (magma_s_vector x, magma_d_vector *y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convertes magma_s_vector from C to Z  <a href="#ga94af20db87a8a9d437c8ab2de15b96cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#gabe87263ee783178c5679b4167f28ba08">magma_sparse_matrix_slag2d</a> (magma_s_sparse_matrix A, magma_d_sparse_matrix *B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convertes magma_s_sparse_matrix from C to Z  <a href="#gabe87263ee783178c5679b4167f28ba08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magmasparse__caux.html#gafc16c425006a4b7d571fc41a00253c60">magmablas_slag2d_sparse</a> (magma_int_t M, magma_int_t N, const float *SA, magma_int_t ldsa, double *A, magma_int_t lda, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SLAG2D converts a SINGLE PRECISION matrix SA to a DOUBLE PRECISION matrix A.  <a href="#gafc16c425006a4b7d571fc41a00253c60"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaffadeed65a929f9ef7560d8478eb3844"></a><!-- doxytag: member="magma_c_blaswrapper.cpp::magma_c_spmv_shift" ref="gaffadeed65a929f9ef7560d8478eb3844" args="(magmaFloatComplex alpha, magma_c_sparse_matrix A, magmaFloatComplex lambda, magma_c_vector x, magmaFloatComplex beta, magma_int_t offset, magma_int_t blocksize, magma_index_t *add_rows, magma_c_vector y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_c_spmv_shift </td>
          <td>(</td>
          <td class="paramtype">magmaFloatComplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_c_sparse_matrix&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_c_vector&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex&nbsp;</td>
          <td class="paramname"> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>blocksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_index_t *&nbsp;</td>
          <td class="paramname"> <em>add_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_c_vector&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a given input matrix A and vectors x, y and scalars alpha, beta the wrapper determines the suitable SpMV computing y = alpha * ( A - lambda I ) * x + beta * y. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>magmaFloatComplex scalar alpha</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>magma_c_sparse_matrix sparse matrix A</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>magmaFloatComplex scalar lambda</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>magma_c_vector input vector x</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beta</em>&nbsp;</td><td>magmaFloatComplex scalar beta</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>magma_int_t in case not the main diagonal is scaled</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocksize</em>&nbsp;</td><td>magma_int_t in case of processing multiple vectors</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>add_rows</em>&nbsp;</td><td>magma_int_t* in case the matrixpowerskernel is used</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>magma_c_vector output vector y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06b2c514d7e9960e45ba4fe27982e1cb"></a><!-- doxytag: member="cpipelinedgmres.cu::magma_ccopyscale" ref="ga06b2c514d7e9960e45ba4fe27982e1cb" args="(int n, int k, magmaFloatComplex *r, magmaFloatComplex *v, magmaFloatComplex *skp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ccopyscale </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>skp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the correction term of the pipelined GMRES according to P. </p>
<p>Ghysels and scales and copies the new search direction</p>
<p>Returns the vector v = r/ ( skp[k] - (sum_i=1^k skp[i]^2) ) .</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>int length of v_i</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>int # skp entries v_i^T * r ( without r )</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>magmaFloatComplex* vector of length n</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>magmaFloatComplex* vector of length n</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>skp</em>&nbsp;</td><td>magmaFloatComplex* array of parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf91b0658650cac167c245db7e7d8aa1d"></a><!-- doxytag: member="clobpcg_residuals.cu::magma_clobpcg_res" ref="gaf91b0658650cac167c245db7e7d8aa1d" args="(magma_int_t num_rows, magma_int_t num_vecs, float *evalues, magmaFloatComplex *X, magmaFloatComplex *R, float *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_clobpcg_res </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>num_vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>evalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This routine computes for Block-LOBPCG, the set of residuals. </p>
<p>R = Ax - x evalues It replaces: for(int i=0; i &lt; n; i++){ magma_caxpy(m, MAGMA_C_MAKE(-evalues[i],0),blockX+i*m,1,blockR+i*m,1); } The memory layout of x is:</p>
<p>/ x1[0] x2[0] x3[0] \ | x1[1] x2[1] x3[1] | x = | x1[2] x2[2] x3[2] | = x1[0] x1[1] x1[2] x1[3] x1[4] x2[0] x2[1] . | x1[3] x2[3] x3[3] | \ x1[4] x2[4] x3[4] /</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_rows</em>&nbsp;</td><td>magma_int_t number of rows</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_vecs</em>&nbsp;</td><td>magma_int_t number of vectors</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evalues</em>&nbsp;</td><td>float* array of eigenvalues/approximations</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>magmaFloatComplex* block of eigenvector approximations</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>magmaFloatComplex* block of residuals</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>float* array of residuals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga589d631eec0f14d10b1be5798d07dd6e"></a><!-- doxytag: member="clobpcg_shift.cu::magma_clobpcg_shift" ref="ga589d631eec0f14d10b1be5798d07dd6e" args="(magma_int_t num_rows, magma_int_t num_vecs, magma_int_t shift, magmaFloatComplex *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_clobpcg_shift </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>num_vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a Block-LOBPCG, the set of residuals (entries consecutive in memory) shrinks and the vectors are shifted in case shift residuals drop below threshold. </p>
<p>The memory layout of x is:</p>
<p>/ x1[0] x2[0] x3[0] \ | x1[1] x2[1] x3[1] | x = | x1[2] x2[2] x3[2] | = x1[0] x2[0] x3[0] x1[1] x2[1] x3[1] x1[2] . | x1[3] x2[3] x3[3] | \ x1[4] x2[4] x3[4] /</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_rows</em>&nbsp;</td><td>magma_int_t number of rows</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_vecs</em>&nbsp;</td><td>magma_int_t number of vectors</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shift</em>&nbsp;</td><td>magma_int_t shift number</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>magmaFloatComplex* input/output vector x </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc756cd3ac68611fb805b1d042b22c5c"></a><!-- doxytag: member="magma_clag2z.cpp::magma_sparse_matrix_clag2z" ref="gafc756cd3ac68611fb805b1d042b22c5c" args="(magma_c_sparse_matrix A, magma_z_sparse_matrix *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sparse_matrix_clag2z </td>
          <td>(</td>
          <td class="paramtype">magma_c_sparse_matrix&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_z_sparse_matrix *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convertes magma_c_sparse_matrix from C to Z </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>magma_c_sparse_matrix input matrix descriptor</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>magma_z_sparse_matrix* output matrix descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe87263ee783178c5679b4167f28ba08"></a><!-- doxytag: member="magma_slag2d.cpp::magma_sparse_matrix_slag2d" ref="gabe87263ee783178c5679b4167f28ba08" args="(magma_s_sparse_matrix A, magma_d_sparse_matrix *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sparse_matrix_slag2d </td>
          <td>(</td>
          <td class="paramtype">magma_s_sparse_matrix&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_d_sparse_matrix *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convertes magma_s_sparse_matrix from C to Z </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>magma_s_sparse_matrix input matrix descriptor</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>magma_d_sparse_matrix* output matrix descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94ef69380991d213440bdad8cdcac252"></a><!-- doxytag: member="magma_clag2z.cpp::magma_vector_clag2z" ref="ga94ef69380991d213440bdad8cdcac252" args="(magma_c_vector x, magma_z_vector *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_vector_clag2z </td>
          <td>(</td>
          <td class="paramtype">magma_c_vector&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_z_vector *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convertes magma_c_vector from C to Z </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>magma_c_vector input vector descriptor</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>magma_z_vector* output vector descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94af20db87a8a9d437c8ab2de15b96cd"></a><!-- doxytag: member="magma_slag2d.cpp::magma_vector_slag2d" ref="ga94af20db87a8a9d437c8ab2de15b96cd" args="(magma_s_vector x, magma_d_vector *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_vector_slag2d </td>
          <td>(</td>
          <td class="paramtype">magma_s_vector&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_d_vector *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convertes magma_s_vector from C to Z </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>magma_s_vector input vector descriptor</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>magma_d_vector* output vector descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae52b910ea64209e25882d07eb1693e36"></a><!-- doxytag: member="clag2z_sparse.cu::magmablas_clag2z_sparse" ref="gae52b910ea64209e25882d07eb1693e36" args="(magma_int_t M, magma_int_t N, const magmaFloatComplex *SA, magma_int_t ldsa, magmaDoubleComplex *A, magma_int_t lda, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void magmablas_clag2z_sparse </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const magmaFloatComplex *&nbsp;</td>
          <td class="paramname"> <em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CLAG2Z converts a COMPLEX matrix SA to a COMPLEX_16 matrix A. </p>
<p>RMAX is the overflow for the COMPLEX arithmetic. CLAG2Z checks that all the entries of A are between -RMAX and RMAX. If not the convertion is aborted and a flag is raised.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>INTEGER The number of lines of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SA</em>&nbsp;</td><td>COMPLEX array, dimension (LDSA,N) On entry, the M-by-N coefficient matrix SA.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldsa</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>COMPLEX_16 array, dimension (LDA,N) On exit, if INFO=0, the M-by-N coefficient matrix A; if INFO&gt;0, the content of A is unspecified.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array SA. LDSA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>= 1: an entry of the matrix A is greater than the COMPLEX overflow threshold, in this case, the content of SA in exit is unspecified. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc16c425006a4b7d571fc41a00253c60"></a><!-- doxytag: member="slag2d_sparse.cu::magmablas_slag2d_sparse" ref="gafc16c425006a4b7d571fc41a00253c60" args="(magma_int_t M, magma_int_t N, const float *SA, magma_int_t ldsa, double *A, magma_int_t lda, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void magmablas_slag2d_sparse </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SLAG2D converts a SINGLE PRECISION matrix SA to a DOUBLE PRECISION matrix A. </p>
<p>RMAX is the overflow for the SINGLE PRECISION arithmetic. SLAG2D checks that all the entries of A are between -RMAX and RMAX. If not the convertion is aborted and a flag is raised.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>INTEGER The number of lines of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SA</em>&nbsp;</td><td>SINGLE PRECISION array, dimension (LDSA,N) On entry, the M-by-N coefficient matrix SA.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldsa</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDA,N) On exit, if INFO=0, the M-by-N coefficient matrix A; if INFO&gt;0, the content of A is unspecified.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array SA. LDSA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>= 1: an entry of the matrix A is greater than the SINGLE PRECISION overflow threshold, in this case, the content of SA in exit is unspecified. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Sep 2014 for MAGMA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
