<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>MAGMA: double precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">1.6.1</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__dgesvd__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">double precision<div class="ingroups"><a class="el" href="group__magma__gesvd__driver.html">SVD: driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6ac1524e23541c747ef0a319fde3af2f"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dgesvd__driver.html#ga6ac1524e23541c747ef0a319fde3af2f">magma_dgesdd</a> (magma_vec_t jobz, magma_int_t m, magma_int_t n, double *A, magma_int_t lda, double *s, double *U, magma_int_t ldu, double *VT, magma_int_t ldvt, double *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga6ac1524e23541c747ef0a319fde3af2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGESDD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors, by using divide-and-conquer method.  <a href="#ga6ac1524e23541c747ef0a319fde3af2f">More...</a><br /></td></tr>
<tr class="separator:ga6ac1524e23541c747ef0a319fde3af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae96893c07d98c00aa2dad4afc76c89f7"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dgesvd__driver.html#gae96893c07d98c00aa2dad4afc76c89f7">magma_dgesvd</a> (magma_vec_t jobu, magma_vec_t jobvt, magma_int_t m, magma_int_t n, double *A, magma_int_t lda, double *s, double *U, magma_int_t ldu, double *VT, magma_int_t ldvt, double *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gae96893c07d98c00aa2dad4afc76c89f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGESVD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and/or right singular vectors.  <a href="#gae96893c07d98c00aa2dad4afc76c89f7">More...</a><br /></td></tr>
<tr class="separator:gae96893c07d98c00aa2dad4afc76c89f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6ac1524e23541c747ef0a319fde3af2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgesdd </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGESDD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors, by using divide-and-conquer method. </p>
<p>The SVD is written</p>
<p>A = U * SIGMA * transpose(V)</p>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns VT = V**T, not V.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t Specifies options for computing all or part of the matrix U:<ul>
<li>= MagmaAllVec: all M columns of U and all N rows of V**T are returned in the arrays U and VT;</li>
<li>= MagmaSomeVec: the first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT;</li>
<li>= MagmaOverwriteVec: If M &gt;= N, the first N columns of U are overwritten on the array A and all rows of V**T are returned in the array VT; otherwise, all columns of U are returned in the array U and the first M rows of V**T are overwritten on the array A;</li>
<li>= MagmaNoVec: no columns of U or rows of V**T are computed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>DOUBLE PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit,<ul>
<li>if JOBZ = MagmaOverwriteVec, if M &gt;= N, A is overwritten with the first N columns of U (the left singular vectors, stored columnwise); otherwise, A is overwritten with the first M rows of V**T (the right singular vectors, stored owwise).</li>
<li>if JOBZ != MagmaOverwriteVec, the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>DOUBLE PRECISION array, dimension (min(M,N)) The singular values of A, sorted so that S(i) &gt;= S(i + 1).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>DOUBLE PRECISION array, dimension (LDU,UCOL) UCOL = M if JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N; UCOL = min(M,N) if JOBZ = MagmaSomeVec.<ul>
<li>If JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N, U contains the M-by-M orthogonal matrix U;</li>
<li>if JOBZ = MagmaSomeVec, U contains the first min(M,N) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBZ = MagmaOverwriteVec and M &gt;= N, or JOBZ = MagmaNoVec, U is not referenced.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldu</td><td>INTEGER The leading dimension of the array U. LDU &gt;= 1; if JOBZ = MagmaSomeVec or MagmaAllVec or JOBZ = MagmaOverwriteVec and M &lt; N, LDU &gt;= M.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td>DOUBLE PRECISION array, dimension (LDVT,N)<ul>
<li>If JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &gt;= N, VT contains the N-by-N orthogonal matrix V**T;</li>
<li>if JOBZ = MagmaSomeVec, VT contains the first min(M,N) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBZ = MagmaOverwriteVec and M &lt; N, or JOBZ = MagmaNoVec, VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvt</td><td>INTEGER The leading dimension of the array VT. LDVT &gt;= 1; if JOBZ = MagmaAllVec or JOBZ = MagmaOverwriteVec and M &gt;= N, LDVT &gt;= N; if JOBZ = MagmaSomeVec, LDVT &gt;= min(M,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. Let x = max(M,N) and y = min(M,N). The optimal block size nb can be obtained through magma_get_dgesvd_nb(N). The threshold for x &gt;&gt; y currently is x &gt;= y*11/6. Required size different than in LAPACK.* In most cases, these sizes should give optimal performance for both MAGMA and LAPACK.<ul>
<li>If JOBZ = MagmaNoVec, if x &gt;&gt; y, LWORK &gt;= 3*y + max( (2*y)*nb, 7*y ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 7*y ).</li>
<li>If JOBZ = MagmaOverwriteVec, if x &gt;&gt; y, LWORK &gt;= y*y + 3*y + max( (2*y)*nb, 4*y*y + 4*y ), prefer LWORK &gt;= y*y + 3*y + max( (2*y)*nb, 4*y*y + 4*y, y*y + y*nb ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 4*y*y + 4*y ).</li>
<li>If JOBZ = MagmaSomeVec, if x &gt;&gt; y, LWORK &gt;= y*y + 3*y + max( (2*y)*nb, 3*y*y + 4*y ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 3*y*y + 4*y ).</li>
<li>If JOBZ = MagmaAllVec, if x &gt;&gt; y, LWORK &gt;= y*y + max( 3*y + max( (2*y)*nb, 3*y*y + 4*y ), y + x ), prefer LWORK &gt;= y*y + max( 3*y + max( (2*y)*nb, 3*y*y + 4*y ), y + x*nb ); otherwise, LWORK &gt;= 3*y + max( (x+y)*nb, 3*y*y + 4*y ). <br />
 If LWORK = -1 but other input arguments are legal, WORK[0] returns the optimal LWORK.</li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (8*min(M,N))</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: DBDSDC did not converge, updating process failed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="gae96893c07d98c00aa2dad4afc76c89f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgesvd </td>
          <td>(</td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGESVD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and/or right singular vectors. </p>
<p>The SVD is written</p>
<p>A = U * SIGMA * conjugate-transpose(V)</p>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A.</p>
<p>Note that the routine returns V**T, not V.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jobu</td><td>magma_vec_t Specifies options for computing all or part of the matrix U:<ul>
<li>= MagmaAllVec: all M columns of U are returned in array U:</li>
<li>= MagmaSomeVec: the first min(m,n) columns of U (the left singular vectors) are returned in the array U;</li>
<li>= MagmaOverwriteVec: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A;</li>
<li>= MagmaNoVec: no columns of U (no left singular vectors) are computed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jobvt</td><td>magma_vec_t Specifies options for computing all or part of the matrix V**T:<ul>
<li>= MagmaAllVec: all N rows of V**T are returned in the array VT;</li>
<li>= MagmaSomeVec: the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT;</li>
<li>= MagmaOverwriteVec: the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A;</li>
<li>= MagmaNoVec: no rows of V**T (no right singular vectors) are computed. <br />
 JOBVT and JOBU cannot both be MagmaOverwriteVec.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>DOUBLE_PRECISION array, dimension (LDA,N) On entry, the M-by-N matrix A. On exit,<ul>
<li>if JOBU = MagmaOverwriteVec, A is overwritten with the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBVT = MagmaOverwriteVec, A is overwritten with the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBU != MagmaOverwriteVec and JOBVT != MagmaOverwriteVec, the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>DOUBLE_PRECISION array, dimension (min(M,N)) The singular values of A, sorted so that S(i) &gt;= S(i+1).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>DOUBLE_PRECISION array, dimension (LDU,UCOL) (LDU,M) if JOBU = MagmaAllVec or (LDU,min(M,N)) if JOBU = MagmaSomeVec.<ul>
<li>If JOBU = MagmaAllVec, U contains the M-by-M orthogonal matrix U;</li>
<li>if JOBU = MagmaSomeVec, U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBU = MagmaNoVec or MagmaOverwriteVec, U is not referenced.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldu</td><td>INTEGER The leading dimension of the array U. LDU &gt;= 1; if JOBU = MagmaSomeVec or MagmaAllVec, LDU &gt;= M.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td>DOUBLE_PRECISION array, dimension (LDVT,N)<ul>
<li>If JOBVT = MagmaAllVec, VT contains the N-by-N orthogonal matrix V**T;</li>
<li>if JOBVT = MagmaSomeVec, VT contains the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBVT = MagmaNoVec or MagmaOverwriteVec, VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvt</td><td>INTEGER The leading dimension of the array VT. LDVT &gt;= 1;<ul>
<li>if JOBVT = MagmaAllVec, LDVT &gt;= N;</li>
<li>if JOBVT = MagmaSomeVec, LDVT &gt;= min(M,N).</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) DOUBLE_PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the required LWORK. if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged superdiagonal elements of an upper bidiagonal matrix B whose diagonal is in S (not necessarily sorted). B satisfies A = U * B * VT, so it has the same singular values as A, and singular vectors related by U and VT.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. LWORK &gt;= (M+N)*nb + 3*min(M,N). For optimum performance with some paths (m &gt;&gt; n and jobu=A,S,O; or n &gt;&gt; m and jobvt=A,S,O), LWORK &gt;= (M+N)*nb + 3*min(M,N) + 2*min(M,N)**2 (see comments inside code). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the required size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if DBDSQR did not converge, INFO specifies how many superdiagonals of an intermediate bidiagonal form B did not converge to zero. See the description of RWORK above for details. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 30 2015 19:00:47 for MAGMA by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
