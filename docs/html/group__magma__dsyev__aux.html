<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MAGMA: double precision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>double precision<br/>
<small>
[<a class="el" href="group__magma__syev__aux.html">Symmetric eigenvalue: auxiliary</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#gad29318916a94d3d5a84fe9263027fedc">magma_dlaex0</a> (magma_int_t n, double *d, double *e, double *Q, magma_int_t ldq, double *work, magma_int_t *iwork, magmaDouble_ptr dwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLAEX0 computes all eigenvalues and the choosen eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#gad29318916a94d3d5a84fe9263027fedc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#ga9d5c7f795fc75ab251735ff1cc6a6e48">magma_dlaex0_m</a> (magma_int_t ngpu, magma_int_t n, double *d, double *e, double *Q, magma_int_t ldq, double *work, magma_int_t *iwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLAEX0 computes all eigenvalues and the choosen eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#ga9d5c7f795fc75ab251735ff1cc6a6e48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#gadbb212d49583e0bc2daf9c3449a15657">magma_dlaex1</a> (magma_int_t n, double *d, double *Q, magma_int_t ldq, magma_int_t *indxq, double rho, magma_int_t cutpnt, double *work, magma_int_t *iwork, magmaDouble_ptr dwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLAEX1 computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix.  <a href="#gadbb212d49583e0bc2daf9c3449a15657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#ga0e0da522cc667a22dbf3f957b46d50b7">magma_dlaex1_m</a> (magma_int_t ngpu, magma_int_t n, double *d, double *Q, magma_int_t ldq, magma_int_t *indxq, double rho, magma_int_t cutpnt, double *work, magma_int_t *iwork, magmaDouble_ptr dwork[], magma_queue_t queues[MagmaMaxGPUs][2], magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLAEX1 computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix.  <a href="#ga0e0da522cc667a22dbf3f957b46d50b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#ga03fb434cea1a00e7c89ad2c230f25d20">magma_dlaex3</a> (magma_int_t k, magma_int_t n, magma_int_t n1, double *d, double *Q, magma_int_t ldq, double rho, double *dlamda, double *Q2, magma_int_t *indx, magma_int_t *ctot, double *w, double *s, magma_int_t *indxq, magmaDouble_ptr dwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLAEX3 finds the roots of the secular equation, as defined by the values in D, W, and RHO, between 1 and K.  <a href="#ga03fb434cea1a00e7c89ad2c230f25d20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#ga06932e6e64fda3cf86a829878004691b">magma_dlaex3_m</a> (magma_int_t ngpu, magma_int_t k, magma_int_t n, magma_int_t n1, double *d, double *Q, magma_int_t ldq, double rho, double *dlamda, double *Q2, magma_int_t *indx, magma_int_t *ctot, double *w, double *s, magma_int_t *indxq, magmaDouble_ptr dwork[], magma_queue_t queues[MagmaMaxGPUs][2], magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLAEX3 finds the roots of the secular equation, as defined by the values in D, W, and RHO, between 1 and K.  <a href="#ga06932e6e64fda3cf86a829878004691b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#ga44594f1cadaf3db2e3cfd5c639914fff">magma_dlatrd</a> (magma_uplo_t uplo, magma_int_t n, magma_int_t nb, double *A, magma_int_t lda, double *e, double *tau, double *W, magma_int_t ldw, magmaDouble_ptr dA, magma_int_t ldda, magmaDouble_ptr dW, magma_int_t lddw)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLATRD reduces NB rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q' * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A.  <a href="#ga44594f1cadaf3db2e3cfd5c639914fff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#gae8c0094f59e9256635bb5806616f4635">magma_dlatrd2</a> (magma_uplo_t uplo, magma_int_t n, magma_int_t nb, double *A, magma_int_t lda, double *e, double *tau, double *W, magma_int_t ldw, magmaDouble_ptr dA, magma_int_t ldda, magmaDouble_ptr dW, magma_int_t lddw, magmaDouble_ptr dwork, magma_int_t ldwork)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLATRD2 reduces NB rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q' * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A.  <a href="#gae8c0094f59e9256635bb5806616f4635"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">magma_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__dsyev__aux.html#gae0680c3506d0d0d95b651efbd5d394d3">magma_dlatrd_mgpu</a> (magma_int_t ngpu, magma_uplo_t uplo, magma_int_t n0, magma_int_t n, magma_int_t nb, magma_int_t nb0, double *A, magma_int_t lda, double *e, double *tau, double *W, magma_int_t ldw, magmaDouble_ptr dA[], magma_int_t ldda, magma_int_t offset, magmaDouble_ptr dW[], magma_int_t lddw, magmaDouble_ptr dwork[], magma_int_t ldwork, magma_int_t k, magmaDouble_ptr dx[], magmaDouble_ptr dy[], double *work, magma_queue_t queues[][10], double *times)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLATRD reduces NB rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q' * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A.  <a href="#gae0680c3506d0d0d95b651efbd5d394d3"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad29318916a94d3d5a84fe9263027fedc"></a><!-- doxytag: member="dlaex0.cpp::magma_dlaex0" ref="gad29318916a94d3d5a84fe9263027fedc" args="(magma_int_t n, double *d, double *e, double *Q, magma_int_t ldq, double *work, magma_int_t *iwork, magmaDouble_ptr dwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlaex0 </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLAEX0 computes all eigenvalues and the choosen eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N) On entry, the main diagonal of the tridiagonal matrix. On exit, its eigenvalues.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N-1) The off-diagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>Q</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ, N) On entry, Q will be the identity matrix. On exit, Q contains the eigenvectors of the tridiagonal matrix.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldq</em>&nbsp;</td><td>INTEGER The leading dimension of the array Q. If eigenvectors are desired, then LDQ &gt;= max(1,N). In any case, LDQ &gt;= 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, the dimension of WORK &gt;= 4*N + N**2.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iwork</em>&nbsp;</td><td>(workspace) INTEGER array, the dimension of IWORK &gt;= 3 + 5*N.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dwork</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, dimension (3*N*N/2+3*N)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>range</em>&nbsp;</td><td>magma_range_t</p>
<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vl</em>&nbsp;</td><td>DOUBLE PRECISION </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vu</em>&nbsp;</td><td>DOUBLE PRECISION If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>il</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iu</em>&nbsp;</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="ga9d5c7f795fc75ab251735ff1cc6a6e48"></a><!-- doxytag: member="dlaex0_m.cpp::magma_dlaex0_m" ref="ga9d5c7f795fc75ab251735ff1cc6a6e48" args="(magma_int_t ngpu, magma_int_t n, double *d, double *e, double *Q, magma_int_t ldq, double *work, magma_int_t *iwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlaex0_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLAEX0 computes all eigenvalues and the choosen eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ngpu</em>&nbsp;</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N) On entry, the main diagonal of the tridiagonal matrix. On exit, its eigenvalues.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N-1) The off-diagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>Q</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ, N) On entry, Q will be the identity matrix. On exit, Q contains the eigenvectors of the tridiagonal matrix.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldq</em>&nbsp;</td><td>INTEGER The leading dimension of the array Q. If eigenvectors are desired, then LDQ &gt;= max(1,N). In any case, LDQ &gt;= 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, the dimension of WORK &gt;= 4*N + N**2.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iwork</em>&nbsp;</td><td>(workspace) INTEGER array, the dimension of IWORK &gt;= 3 + 5*N.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>range</em>&nbsp;</td><td>magma_range_t</p>
<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vl</em>&nbsp;</td><td>DOUBLE PRECISION </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vu</em>&nbsp;</td><td>DOUBLE PRECISION If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>il</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iu</em>&nbsp;</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="gadbb212d49583e0bc2daf9c3449a15657"></a><!-- doxytag: member="dlaex1.cpp::magma_dlaex1" ref="gadbb212d49583e0bc2daf9c3449a15657" args="(magma_int_t n, double *d, double *Q, magma_int_t ldq, magma_int_t *indxq, double rho, magma_int_t cutpnt, double *work, magma_int_t *iwork, magmaDouble_ptr dwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlaex1 </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>indxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>cutpnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLAEX1 computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix. </p>
<p>T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)</p>
<p>where Z = Q'u, u is a vector of length N with ones in the CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.</p>
<p>The eigenvectors of the original matrix are stored in Q, and the eigenvalues are in D. The algorithm consists of three stages:</p>
<p>The first stage consists of deflating the size of the problem when there are multiple eigenvalues or if there is a zero in the Z vector. For each such occurence the dimension of the secular equation problem is reduced by one. This stage is performed by the routine DLAED2.</p>
<p>The second stage consists of calculating the updated eigenvalues. This is done by finding the roots of the secular equation via the routine DLAED4 (as called by DLAED3). This routine also calculates the eigenvectors of the current problem.</p>
<p>The final stage consists of computing the updated eigenvectors directly using the updated eigenvalues. The eigenvectors for the current problem are multiplied with the eigenvectors from the overall problem.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N) On entry, the eigenvalues of the rank-1-perturbed matrix. On exit, the eigenvalues of the repaired matrix.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>Q</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ,N) On entry, the eigenvectors of the rank-1-perturbed matrix. On exit, the eigenvectors of the repaired tridiagonal matrix.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldq</em>&nbsp;</td><td>INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>indxq</em>&nbsp;</td><td>INTEGER array, dimension (N) On entry, the permutation which separately sorts the two subproblems in D into ascending order. On exit, the permutation which will reintegrate the subproblems back into sorted order, i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rho</em>&nbsp;</td><td>DOUBLE PRECISION The subdiagonal entry used to create the rank-1 modification.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cutpnt</em>&nbsp;</td><td>INTEGER The location of the last eigenvalue in the leading sub-matrix. min(1,N) &lt;= CUTPNT &lt;= N/2.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, dimension (4*N + N**2)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iwork</em>&nbsp;</td><td>(workspace) INTEGER array, dimension (4*N)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dwork</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, dimension (3*N*N/2+3*N)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>range</em>&nbsp;</td><td>magma_range_t</p>
<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vl</em>&nbsp;</td><td>DOUBLE PRECISION </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vu</em>&nbsp;</td><td>DOUBLE PRECISION if RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>il</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iu</em>&nbsp;</td><td>INTEGER if RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if INFO = 1, an eigenvalue did not converge</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="ga0e0da522cc667a22dbf3f957b46d50b7"></a><!-- doxytag: member="dlaex1_m.cpp::magma_dlaex1_m" ref="ga0e0da522cc667a22dbf3f957b46d50b7" args="(magma_int_t ngpu, magma_int_t n, double *d, double *Q, magma_int_t ldq, magma_int_t *indxq, double rho, magma_int_t cutpnt, double *work, magma_int_t *iwork, magmaDouble_ptr dwork[], magma_queue_t queues[MagmaMaxGPUs][2], magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlaex1_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>indxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>cutpnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dwork</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_queue_t&nbsp;</td>
          <td class="paramname"> <em>queues</em>[MagmaMaxGPUs][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLAEX1 computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix. </p>
<p>T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)</p>
<p>where Z = Q'u, u is a vector of length N with ones in the CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.</p>
<p>The eigenvectors of the original matrix are stored in Q, and the eigenvalues are in D. The algorithm consists of three stages:</p>
<p>The first stage consists of deflating the size of the problem when there are multiple eigenvalues or if there is a zero in the Z vector. For each such occurence the dimension of the secular equation problem is reduced by one. This stage is performed by the routine DLAED2.</p>
<p>The second stage consists of calculating the updated eigenvalues. This is done by finding the roots of the secular equation via the routine DLAED4 (as called by DLAED3). This routine also calculates the eigenvectors of the current problem.</p>
<p>The final stage consists of computing the updated eigenvectors directly using the updated eigenvalues. The eigenvectors for the current problem are multiplied with the eigenvectors from the overall problem.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ngpu</em>&nbsp;</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N) On entry, the eigenvalues of the rank-1-perturbed matrix. On exit, the eigenvalues of the repaired matrix.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>Q</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ,N) On entry, the eigenvectors of the rank-1-perturbed matrix. On exit, the eigenvectors of the repaired tridiagonal matrix.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldq</em>&nbsp;</td><td>INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>indxq</em>&nbsp;</td><td>INTEGER array, dimension (N) On entry, the permutation which separately sorts the two subproblems in D into ascending order. On exit, the permutation which will reintegrate the subproblems back into sorted order, i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rho</em>&nbsp;</td><td>DOUBLE PRECISION The subdiagonal entry used to create the rank-1 modification.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cutpnt</em>&nbsp;</td><td>INTEGER The location of the last eigenvalue in the leading sub-matrix. min(1,N) &lt;= CUTPNT &lt;= N/2.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, dimension (4*N + N**2)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iwork</em>&nbsp;</td><td>(workspace) INTEGER array, dimension (4*N)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dwork</em>&nbsp;</td><td>(devices workspaces) DOUBLE PRECISION array of arrays, dimension NRGPU. if NRGPU = 1 the dimension of the first workspace should be (3*N*N/2+3*N) otherwise the NRGPU workspaces should have the size ceil((N-N1) * (N-N1) / floor(ngpu/2)) + NB * ((N-N1) + (N-N1) / floor(ngpu/2))</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queues</em>&nbsp;</td><td>(device queues) magma_queue_t array, dimension (MagmaMaxGPUs,2)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>range</em>&nbsp;</td><td>magma_range_t</p>
<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vl</em>&nbsp;</td><td>DOUBLE PRECISION </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vu</em>&nbsp;</td><td>DOUBLE PRECISION if RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>il</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iu</em>&nbsp;</td><td>INTEGER if RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if INFO = 1, an eigenvalue did not converge</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="ga03fb434cea1a00e7c89ad2c230f25d20"></a><!-- doxytag: member="dlaex3.cpp::magma_dlaex3" ref="ga03fb434cea1a00e7c89ad2c230f25d20" args="(magma_int_t k, magma_int_t n, magma_int_t n1, double *d, double *Q, magma_int_t ldq, double rho, double *dlamda, double *Q2, magma_int_t *indx, magma_int_t *ctot, double *w, double *s, magma_int_t *indxq, magmaDouble_ptr dwork, magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlaex3 </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dlamda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>ctot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>indxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLAEX3 finds the roots of the secular equation, as defined by the values in D, W, and RHO, between 1 and K. </p>
<p>It makes the appropriate calls to DLAED4 and then updates the eigenvectors by multiplying the matrix of eigenvectors of the pair of eigensystems being combined by the matrix of eigenvectors of the K-by-K system which is solved here.</p>
<p>It is used in the last step when only a part of the eigenvectors is required. It compute only the required part of the eigenvectors and the rest is not used.</p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>k</em>&nbsp;</td><td>INTEGER The number of terms in the rational function to be solved by DLAED4. K &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The number of rows and columns in the Q matrix. N &gt;= K (deflation may result in N &gt; K).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1</em>&nbsp;</td><td>INTEGER The location of the last eigenvalue in the leading submatrix. min(1,N) &lt;= N1 &lt;= N/2.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N) D(I) contains the updated eigenvalues for 1 &lt;= I &lt;= K.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Q</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ,N) Initially the first K columns are used as workspace. On output the columns ??? to ??? contain the updated eigenvectors.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldq</em>&nbsp;</td><td>INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rho</em>&nbsp;</td><td>DOUBLE PRECISION The value of the parameter in the rank one update equation. RHO &gt;= 0 required.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>dlamda</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (K) The first K elements of this array contain the old roots of the deflated updating problem. These are the poles of the secular equation. May be changed on output by having lowest order bit set to zero on Cray X-MP, Cray Y-MP, Cray-2, or Cray C-90, as described above.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Q2</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ2, N) The first K columns of this matrix contain the non-deflated eigenvectors for the split problem. TODO what is LDQ2?</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>indx</em>&nbsp;</td><td>INTEGER array, dimension (N) The permutation used to arrange the columns of the deflated Q matrix into three groups (see DLAED2). The rows of the eigenvectors found by DLAED4 must be likewise permuted before the matrix multiply can take place.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctot</em>&nbsp;</td><td>INTEGER array, dimension (4) A count of the total number of the various types of columns in Q, as described in INDX. The fourth column type is any column which has been deflated.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>w</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (K) The first K elements of this array contain the components of the deflation-adjusted updating vector. Destroyed on output.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, dimension (N1 + 1)*K Will contain the eigenvectors of the repaired matrix which will be multiplied by the previously accumulated eigenvectors to update the system.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>indxq</em>&nbsp;</td><td>INTEGER array, dimension (N) On exit, the permutation which will reintegrate the subproblems back into sorted order, i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dwork</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, dimension (3*N*N/2+3*N)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>range</em>&nbsp;</td><td>magma_range_t</p>
<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found. TODO verify range, vl, vu, il, iu -- copied from dlaex1.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vl</em>&nbsp;</td><td>DOUBLE PRECISION </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vu</em>&nbsp;</td><td>DOUBLE PRECISION if RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>il</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iu</em>&nbsp;</td><td>INTEGER if RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if INFO = 1, an eigenvalue did not converge</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="ga06932e6e64fda3cf86a829878004691b"></a><!-- doxytag: member="dlaex3_m.cpp::magma_dlaex3_m" ref="ga06932e6e64fda3cf86a829878004691b" args="(magma_int_t ngpu, magma_int_t k, magma_int_t n, magma_int_t n1, double *d, double *Q, magma_int_t ldq, double rho, double *dlamda, double *Q2, magma_int_t *indx, magma_int_t *ctot, double *w, double *s, magma_int_t *indxq, magmaDouble_ptr dwork[], magma_queue_t queues[MagmaMaxGPUs][2], magma_range_t range, double vl, double vu, magma_int_t il, magma_int_t iu, magma_int_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlaex3_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dlamda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>ctot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>indxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dwork</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_queue_t&nbsp;</td>
          <td class="paramname"> <em>queues</em>[MagmaMaxGPUs][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLAEX3 finds the roots of the secular equation, as defined by the values in D, W, and RHO, between 1 and K. </p>
<p>It makes the appropriate calls to DLAED4 and then updates the eigenvectors by multiplying the matrix of eigenvectors of the pair of eigensystems being combined by the matrix of eigenvectors of the K-by-K system which is solved here.</p>
<p>It is used in the last step when only a part of the eigenvectors is required. It compute only the required part of the eigenvectors and the rest is not used.</p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ngpu</em>&nbsp;</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>k</em>&nbsp;</td><td>INTEGER The number of terms in the rational function to be solved by DLAED4. K &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The number of rows and columns in the Q matrix. N &gt;= K (deflation may result in N &gt; K).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1</em>&nbsp;</td><td>INTEGER The location of the last eigenvalue in the leading submatrix. min(1,N) &lt;= N1 &lt;= N/2.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (N) D(I) contains the updated eigenvalues for 1 &lt;= I &lt;= K.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Q</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ,N) Initially the first K columns are used as workspace. On output the columns ??? to ??? contain the updated eigenvectors.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldq</em>&nbsp;</td><td>INTEGER The leading dimension of the array Q. LDQ &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rho</em>&nbsp;</td><td>DOUBLE PRECISION The value of the parameter in the rank one update equation. RHO &gt;= 0 required.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>dlamda</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (K) The first K elements of this array contain the old roots of the deflated updating problem. These are the poles of the secular equation. May be changed on output by having lowest order bit set to zero on Cray X-MP, Cray Y-MP, Cray-2, or Cray C-90, as described above.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Q2</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (LDQ2, N) The first K columns of this matrix contain the non-deflated eigenvectors for the split problem.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>indx</em>&nbsp;</td><td>INTEGER array, dimension (N) The permutation used to arrange the columns of the deflated Q matrix into three groups (see DLAED2). The rows of the eigenvectors found by DLAED4 must be likewise permuted before the matrix multiply can take place.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctot</em>&nbsp;</td><td>INTEGER array, dimension (4) A count of the total number of the various types of columns in Q, as described in INDX. The fourth column type is any column which has been deflated.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>w</em>&nbsp;</td><td>DOUBLE PRECISION array, dimension (K) The first K elements of this array contain the components of the deflation-adjusted updating vector. Destroyed on output.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>(workspace) DOUBLE PRECISION array, dimension (N1 + 1)*K Will contain the eigenvectors of the repaired matrix which will be multiplied by the previously accumulated eigenvectors to update the system.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>indxq</em>&nbsp;</td><td>INTEGER array, dimension (N) On exit, the permutation which will reintegrate the subproblems back into sorted order, i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dwork</em>&nbsp;</td><td>(devices workspaces) DOUBLE PRECISION array of arrays, dimension NRGPU. if NRGPU = 1 the dimension of the first workspace should be (3*N*N/2+3*N) otherwise the NRGPU workspaces should have the size ceil((N-N1) * (N-N1) / floor(ngpu/2)) + NB * ((N-N1) + (N-N1) / floor(ngpu/2))</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queues</em>&nbsp;</td><td>(device queues) magma_queue_t array, dimension (MagmaMaxGPUs,2)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>range</em>&nbsp;</td><td>magma_range_t</p>
<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found. TODO verify range, vl, vu, il, iu -- copied from dlaex1.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vl</em>&nbsp;</td><td>DOUBLE PRECISION </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vu</em>&nbsp;</td><td>DOUBLE PRECISION if RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>il</em>&nbsp;</td><td>INTEGER </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iu</em>&nbsp;</td><td>INTEGER if RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>INTEGER</p>
<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if INFO = 1, an eigenvalue did not converge</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="ga44594f1cadaf3db2e3cfd5c639914fff"></a><!-- doxytag: member="dlatrd.cpp::magma_dlatrd" ref="ga44594f1cadaf3db2e3cfd5c639914fff" args="(magma_uplo_t uplo, magma_int_t n, magma_int_t nb, double *A, magma_int_t lda, double *e, double *tau, double *W, magma_int_t ldw, magmaDouble_ptr dA, magma_int_t ldda, magmaDouble_ptr dW, magma_int_t lddw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlatrd </td>
          <td>(</td>
          <td class="paramtype">magma_uplo_t&nbsp;</td>
          <td class="paramname"> <em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lddw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLATRD reduces NB rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q' * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A. </p>
<p>If UPLO = MagmaUpper, DLATRD reduces the last NB rows and columns of a matrix, of which the upper triangle is supplied; if UPLO = MagmaLower, DLATRD reduces the first NB rows and columns of a matrix, of which the lower triangle is supplied.</p>
<p>This is an auxiliary routine called by DSYTRD.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uplo</em>&nbsp;</td><td>magma_uplo_t Specifies whether the upper or lower triangular part of the symmetric matrix A is stored:</p>
<ul>
<li>= MagmaUpper: Upper triangular</li>
<li>= MagmaLower: Lower triangular</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nb</em>&nbsp;</td><td>INTEGER The number of rows and columns to be reduced.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = MagmaLower, the leading n-by-n lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit:</p>
<ul>
<li>if UPLO = MagmaUpper, the last NB columns have been reduced to tridiagonal form, with the diagonal elements overwriting the diagonal elements of A; the elements above the diagonal with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors;</li>
<li>if UPLO = MagmaLower, the first NB columns have been reduced to tridiagonal form, with the diagonal elements overwriting the diagonal elements of A; the elements below the diagonal with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= (1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (N-1) If UPLO = MagmaUpper, E(n-nb:n-1) contains the superdiagonal elements of the last NB columns of the reduced matrix; if UPLO = MagmaLower, E(1:nb) contains the subdiagonal elements of the first NB columns of the reduced matrix.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (N-1) The scalar factors of the elementary reflectors, stored in TAU(n-nb:n-1) if UPLO = MagmaUpper, and in TAU(1:nb) if UPLO = MagmaLower. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>W</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (LDW,NB) The n-by-nb matrix W required to update the unreduced part of A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldw</em>&nbsp;</td><td>INTEGER The leading dimension of the array W. LDW &gt;= max(1,N).</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- If UPLO = MagmaUpper, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(n) H(n-1) . . . H(n-nb+1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i), and tau in TAU(i-1).</p>
<p>If UPLO = MagmaLower, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(nb).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i), and tau in TAU(i).</p>
<p>The elements of the vectors v together form the n-by-nb matrix V which is needed, with W, to apply the transformation to the unreduced part of the matrix, using a symmetric rank-2k update of the form: A := A - V*W' - W*V'.</p>
<p>The contents of A on exit are illustrated by the following examples with n = 5 and nb = 2:</p>
<p>if UPLO = MagmaUpper: if UPLO = MagmaLower:</p>
<p>( a a a v4 v5 ) ( d ) ( a a v4 v5 ) ( 1 d ) ( a 1 v5 ) ( v1 1 a ) ( d 1 ) ( v1 v2 a a ) ( d ) ( v1 v2 a a a )</p>
<p>where d denotes a diagonal element of the reduced matrix, a denotes an element of the original matrix that is unchanged, and vi denotes an element of the vector defining H(i). </p>

</div>
</div>
<a class="anchor" id="gae8c0094f59e9256635bb5806616f4635"></a><!-- doxytag: member="dlatrd2.cpp::magma_dlatrd2" ref="gae8c0094f59e9256635bb5806616f4635" args="(magma_uplo_t uplo, magma_int_t n, magma_int_t nb, double *A, magma_int_t lda, double *e, double *tau, double *W, magma_int_t ldw, magmaDouble_ptr dA, magma_int_t ldda, magmaDouble_ptr dW, magma_int_t lddw, magmaDouble_ptr dwork, magma_int_t ldwork)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlatrd2 </td>
          <td>(</td>
          <td class="paramtype">magma_uplo_t&nbsp;</td>
          <td class="paramname"> <em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lddw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldwork</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLATRD2 reduces NB rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q' * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A. </p>
<p>If UPLO = MagmaUpper, DLATRD reduces the last NB rows and columns of a matrix, of which the upper triangle is supplied; if UPLO = MagmaLower, DLATRD reduces the first NB rows and columns of a matrix, of which the lower triangle is supplied.</p>
<p>This is an auxiliary routine called by DSYTRD2_GPU. It uses an accelerated HEMV that needs extra memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uplo</em>&nbsp;</td><td>magma_uplo_t Specifies whether the upper or lower triangular part of the symmetric matrix A is stored:</p>
<ul>
<li>= MagmaUpper: Upper triangular</li>
<li>= MagmaLower: Lower triangular</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nb</em>&nbsp;</td><td>INTEGER The number of rows and columns to be reduced.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = MagmaLower, the leading n-by-n lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit:</p>
<ul>
<li>if UPLO = MagmaUpper, the last NB columns have been reduced to tridiagonal form, with the diagonal elements overwriting the diagonal elements of A; the elements above the diagonal with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors;</li>
<li>if UPLO = MagmaLower, the first NB columns have been reduced to tridiagonal form, with the diagonal elements overwriting the diagonal elements of A; the elements below the diagonal with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= (1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (N-1) If UPLO = MagmaUpper, E(n-nb:n-1) contains the superdiagonal elements of the last NB columns of the reduced matrix; if UPLO = MagmaLower, E(1:nb) contains the subdiagonal elements of the first NB columns of the reduced matrix.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (N-1) The scalar factors of the elementary reflectors, stored in TAU(n-nb:n-1) if UPLO = MagmaUpper, and in TAU(1:nb) if UPLO = MagmaLower. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>W</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (LDW,NB) The n-by-nb matrix W required to update the unreduced part of A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldw</em>&nbsp;</td><td>INTEGER The leading dimension of the array W. LDW &gt;= max(1,N).</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- If UPLO = MagmaUpper, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(n) H(n-1) . . . H(n-nb+1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i), and tau in TAU(i-1).</p>
<p>If UPLO = MagmaLower, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(nb).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i), and tau in TAU(i).</p>
<p>The elements of the vectors v together form the n-by-nb matrix V which is needed, with W, to apply the transformation to the unreduced part of the matrix, using a symmetric rank-2k update of the form: A := A - V*W' - W*V'.</p>
<p>The contents of A on exit are illustrated by the following examples with n = 5 and nb = 2:</p>
<p>if UPLO = MagmaUpper: if UPLO = MagmaLower:</p>
<p>( a a a v4 v5 ) ( d ) ( a a v4 v5 ) ( 1 d ) ( a 1 v5 ) ( v1 1 a ) ( d 1 ) ( v1 v2 a a ) ( d ) ( v1 v2 a a a )</p>
<p>where d denotes a diagonal element of the reduced matrix, a denotes an element of the original matrix that is unchanged, and vi denotes an element of the vector defining H(i). </p>

</div>
</div>
<a class="anchor" id="gae0680c3506d0d0d95b651efbd5d394d3"></a><!-- doxytag: member="dlatrd_mgpu.cpp::magma_dlatrd_mgpu" ref="gae0680c3506d0d0d95b651efbd5d394d3" args="(magma_int_t ngpu, magma_uplo_t uplo, magma_int_t n0, magma_int_t n, magma_int_t nb, magma_int_t nb0, double *A, magma_int_t lda, double *e, double *tau, double *W, magma_int_t ldw, magmaDouble_ptr dA[], magma_int_t ldda, magma_int_t offset, magmaDouble_ptr dW[], magma_int_t lddw, magmaDouble_ptr dwork[], magma_int_t ldwork, magma_int_t k, magmaDouble_ptr dx[], magmaDouble_ptr dy[], double *work, magma_queue_t queues[][10], double *times)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dlatrd_mgpu </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&nbsp;</td>
          <td class="paramname"> <em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>nb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dA</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dW</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>lddw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dwork</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>ldwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&nbsp;</td>
          <td class="paramname"> <em>dy</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_queue_t&nbsp;</td>
          <td class="paramname"> <em>queues</em>[][10], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>times</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLATRD reduces NB rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q' * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A. </p>
<p>If UPLO = MagmaUpper, DLATRD reduces the last NB rows and columns of a matrix, of which the upper triangle is supplied; if UPLO = MagmaLower, DLATRD reduces the first NB rows and columns of a matrix, of which the lower triangle is supplied.</p>
<p>This is an auxiliary routine called by DSYTRD.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uplo</em>&nbsp;</td><td>magma_uplo_t Specifies whether the upper or lower triangular part of the symmetric matrix A is stored:</p>
<ul>
<li>= MagmaUpper: Upper triangular</li>
<li>= MagmaLower: Lower triangular</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>INTEGER The order of the matrix A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nb</em>&nbsp;</td><td>INTEGER The number of rows and columns to be reduced.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (LDA,N) On entry, the symmetric matrix A. If UPLO = MagmaUpper, the leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If UPLO = MagmaLower, the leading n-by-n lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit:</p>
<ul>
<li>if UPLO = MagmaUpper, the last NB columns have been reduced to tridiagonal form, with the diagonal elements overwriting the diagonal elements of A; the elements above the diagonal with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors;</li>
<li>if UPLO = MagmaLower, the first NB columns have been reduced to tridiagonal form, with the diagonal elements overwriting the diagonal elements of A; the elements below the diagonal with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors. See Further Details.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>INTEGER The leading dimension of the array A. LDA &gt;= (1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (N-1) If UPLO = MagmaUpper, E(n-nb:n-1) contains the superdiagonal elements of the last NB columns of the reduced matrix; if UPLO = MagmaLower, E(1:nb) contains the subdiagonal elements of the first NB columns of the reduced matrix.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tau</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (N-1) The scalar factors of the elementary reflectors, stored in TAU(n-nb:n-1) if UPLO = MagmaUpper, and in TAU(1:nb) if UPLO = MagmaLower. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>W</em>&nbsp;</td><td>DOUBLE_PRECISION array, dimension (LDW,NB) The n-by-nb matrix W required to update the unreduced part of A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldw</em>&nbsp;</td><td>INTEGER The leading dimension of the array W. LDW &gt;= max(1,N).</td></tr>
  </table>
  </dd>
</dl>
<p>Further Details --------------- If UPLO = MagmaUpper, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(n) H(n-1) . . . H(n-nb+1).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i), and tau in TAU(i-1).</p>
<p>If UPLO = MagmaLower, the matrix Q is represented as a product of elementary reflectors</p>
<p>Q = H(1) H(2) . . . H(nb).</p>
<p>Each H(i) has the form</p>
<p>H(i) = I - tau * v * v'</p>
<p>where tau is a real scalar, and v is a real vector with v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i), and tau in TAU(i).</p>
<p>The elements of the vectors v together form the n-by-nb matrix V which is needed, with W, to apply the transformation to the unreduced part of the matrix, using a symmetric rank-2k update of the form: A := A - V*W' - W*V'.</p>
<p>The contents of A on exit are illustrated by the following examples with n = 5 and nb = 2:</p>
<p>if UPLO = MagmaUpper: if UPLO = MagmaLower:</p>
<p>( a a a v4 v5 ) ( d ) ( a a v4 v5 ) ( 1 d ) ( a 1 v5 ) ( v1 1 a ) ( d 1 ) ( v1 v2 a a ) ( d ) ( v1 v2 a a a )</p>
<p>where d denotes a diagonal element of the reduced matrix, a denotes an element of the original matrix that is unchanged, and vi denotes an element of the vector defining H(i). </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 15 Nov 2014 for MAGMA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
